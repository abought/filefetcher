"""
Test the manager functionality
- Find, download, or build assets
- Set a custom URL
"""
from unittest import mock

import pytest

from filefetcher import exceptions, manager


@pytest.fixture
def mocked_manager(tmpdir, local_manifest):
    """
    A fixture in which the "build" and "download" methods are replaced with default implementations that always
        succeed, without performing any actual resource-intensive actions
    """
    fixture = manager.AssetManager(
        'mypackage', 'https://test.example/assets/manifest.json',
        local_manifest=tmpdir / 'manifest.json',
        auto_fetch=False, auto_build=False, auto_load=False
    )
    fixture._local = local_manifest

    def fixture_add_record(item_type, save=True, **kwargs):
        # Dummy method: Adds just enough of a record to be found by the manager
        fixture.add_recipe(
            item_type,
            source=lambda manager, item_type: ('', {}),
            **kwargs
        )
        # Note this adds a filename manually, bypassing the usual `_source_path` functionality
        # This is an example of where the bounds between user and system tags blur
        return fixture._local.add_record(item_type, _path='item.txt', **kwargs)

    fixture.build = mock.Mock(side_effect=fixture_add_record)
    fixture.download = mock.Mock(side_effect=fixture_add_record)
    return fixture


# Test the three different ways to build an asset: cached, download, or build
def test_manager_finds_local_asset(mocked_manager):
    out_fn = mocked_manager.locate('snp_to_rsid', genome_build='GRCh37')
    assert out_fn == mocked_manager._local.get_path('iamthenewest_snp_to_rsid.lmdb')


def test_manager_errors_when_asset_not_found(mocked_manager):
    with pytest.raises(exceptions.NoMatchingAsset):
        mocked_manager.locate('nothingtosee', but='us_chickens')


def test_manager_downloads_asset_if_none_locally(mocked_manager: manager.AssetManager):
    mocked_manager._auto_fetch = True

    out_fn = mocked_manager.locate('to_download', atag='avalue')
    assert out_fn == mocked_manager._local.get_path('item.txt')
    assert mocked_manager.download.call_count == 1
    assert mocked_manager.build.call_count == 0


def test_manager_builds_asset_if_none_locally(mocked_manager: manager.AssetManager):
    mocked_manager._auto_build = True

    out_fn = mocked_manager.locate('to_build', atag='avalue')
    assert out_fn == mocked_manager._local.get_path('item.txt')
    assert mocked_manager.download.call_count == 0
    assert mocked_manager.build.call_count == 1


# Test default folder selection
def test_base_cache_dir_uses_explicit_value(monkeypatch):
    monkeypatch.setenv('MYPACKAGE_ASSETS_DIR', '/data2')
    fixture = manager.AssetManager(
        'mypackage',
        'https://test.example/assets/manifest.json',
        local_manifest='/data/mypackage/manifest.json',
        auto_load=False
    )
    assert fixture._local._base_path == '/data/mypackage'


def test_base_cache_dir_uses_envvar(monkeypatch):
    monkeypatch.setenv('MYPACKAGE_ASSETS_DIR', '/data2')
    fixture = manager.AssetManager('mypackage', 'https://test.example/assets/manifest.json', auto_load=False)
    assert fixture._local._base_path == '/data2/mypackage'


def test_base_cache_dir_auto_selected_somewhere(monkeypatch):
    fixture = manager.AssetManager('mypackage', 'https://test.example/assets/manifest.json', auto_load=False)
    assert '.assets' in fixture._local._base_path  # a path generated by the default implementation


# Test that upon (real) download/build, a new file is successfully copied into the cache directory
# TODO: Test manifest is saved and can be referenced later
